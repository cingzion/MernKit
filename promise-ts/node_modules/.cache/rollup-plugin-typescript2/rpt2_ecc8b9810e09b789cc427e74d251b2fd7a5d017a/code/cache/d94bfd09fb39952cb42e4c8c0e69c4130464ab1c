{"code":"/**\r\n   * 1、promise 可以解决多个异步并行执行，最终得到所有的结果\r\n   * 2、异步嵌套问题\r\n   *\r\n   *\r\n   *\r\n   * 01、每个 promise 都有三个状态\r\n   *      -1：pending 等待态\r\n   *      -2：resolve 标识变成、成功态\r\n   *      -3：fulfilled reject 标识变成失败态 rejected\r\n   *\r\n   * 02、每个 promise 需要有一个 then 方法，传入两个参数\r\n   *      一个是成功的回调\r\n   *      另一个是失败的回调\r\n   * 03、new Promise 会立即执行\r\n   *\r\n   * 04、一旦成功就不能\"失败\"，一旦失败就不能\"成功\", 状态不可逆行\r\n   *\r\n   * 05、当 promise 抛出异常后，也会走失败态\r\n   *     Promise a+ 规范：https://promisesaplus.com\r\n   */\r\n// 异常处理\r\nvar tryCatchFn = function (resolve, reject) {\r\n    try {\r\n        // 失败调失败\r\n        resolve();\r\n    }\r\n    catch (e) {\r\n        reject(e);\r\n    }\r\n};\r\n// 一个 promise 有三个状态\r\nvar Promise = /** @class */ (function () {\r\n    // 构造函数\r\n    function Promise(executor) {\r\n        var _this = this;\r\n        this.status = \"PENDING\" /* pending */; // 当前默认状态\r\n        this.value = undefined; // 成功原因\r\n        this.reason = undefined; // 失败原因\r\n        this.onResolveCallback = []; // 成功的回调\r\n        this.onRejectCallback = []; // 失败的回调\r\n        // 成功的回调\r\n        var resolve = function (value) {\r\n            if (_this.status === \"PENDING\" /* pending */) { // 如果当前的状态是等待态，我就把下面的状态存起来\r\n                // 修改状态\r\n                _this.status = \"FULFILLED\" /* fulfilled */; // 修改成功的状态\r\n                _this.value = value; // 修改成功的原因\r\n                // 发布订阅方法\r\n                _this.onResolveCallback.forEach(function (fn) { return fn(); });\r\n            }\r\n        };\r\n        // 失败的回调\r\n        var reject = function (reason) {\r\n            if (_this.status === \"PENDING\" /* pending */) {\r\n                _this.status = \"REJECTED\" /* rejected */; // 修改失败的状态\r\n                _this.reason = reason; // 修改失败原因\r\n                // 发布订阅方法\r\n                _this.onRejectCallback.forEach(function (fn) { return fn(); });\r\n            }\r\n        };\r\n        // 捕获异常\r\n        tryCatchFn(function () {\r\n            executor(resolve, reject);\r\n        }, function (e) {\r\n            reject(e);\r\n        });\r\n    }\r\n    // then 方法\r\n    /**\r\n     * onFulfilled\r\n     * onRejected\r\n     */\r\n    Promise.prototype.then = function (onFulfilled, onRejected) {\r\n        var _this = this;\r\n        // 每次调用 then 都会产生一个全新的 promise\r\n        var promise2 = new Promise(function (resolve, reject) {\r\n            // 判断当前的状态，是不是成功\r\n            if (_this.status === \"FULFILLED\" /* fulfilled */) {\r\n                tryCatchFn(function () {\r\n                    // 成功调成功\r\n                    var x = onFulfilled(_this.value); // 用 then 的返回值，作为下一次 then 的成功结果\r\n                    resolve(x);\r\n                }, function (e) {\r\n                    reject(e);\r\n                });\r\n            }\r\n            // 判断当前的状态， 是不是失败\r\n            if (_this.status === \"REJECTED\" /* rejected */) {\r\n                tryCatchFn(function () {\r\n                    // 失败调失败\r\n                    var x = onRejected(_this.reason);\r\n                    resolve(x);\r\n                }, function (e) {\r\n                    reject(e);\r\n                });\r\n            }\r\n            // 判断当前的状态，是等待态\r\n            if (_this.status === \"PENDING\" /* pending */) {\r\n                // 订阅\r\n                _this.onResolveCallback.push(function () {\r\n                    // 这里的好处就是可以增加额外的逻辑\r\n                    var x = onFulfilled(_this.value);\r\n                    resolve(x);\r\n                });\r\n                _this.onRejectCallback.push(function () {\r\n                    // 这里的好处就是可以增加额外的逻辑\r\n                    var x = onRejected(_this.reason);\r\n                    resolve(x);\r\n                });\r\n            }\r\n        });\r\n        return promise2;\r\n    };\r\n    return Promise;\r\n}());\r\nexport default Promise;\r\n","references":[]}
